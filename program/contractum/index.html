<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>RGB smart contracts</title>
  <link rel="stylesheet" href="/tachyons-ext.css">
  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="/front.css">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  <meta http-equiv="pragma" content="no-cache">
  
    <meta name="description" content="">

    <meta property="og:title" content="Programming with Contractum" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://rgb.tech/rgb-banner.png" />
    <meta name="twitter:card" content="summary_large_image">

    <meta property="og:description" content="">
    <meta property="og:site_name" content="RGB protocol">

    <meta name="twitter:site" content="@lnp_bp">

</head>

<body>
<nav class="flex flex-row justify-center justify-end-l items-center flex-wrap ph2 pl3-ns pr3-ns pb3">
  <div id="logo" class="flex-auto w-100 w-auto-l self-start self-center tc tl-l">
    <a href="/">
      <img alt="RGB Logo" src="/logo/rgb-symbol-color.svg">
    </a>
  </div>
  <ul class="nav list w-100 w-auto-l flex flex-none flex-row flex-wrap justify-center justify-end-l items-center pv2 ph0 ph4-ns">
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/install">Install</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/learn">Learn</a></li>
    <!-- li class="tc pv2 ph2 ph4-ns flex-20-s">Tools</li -->
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/governance">Governance</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://t.me/rgbtelegram">Community</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/blog">Blog</a></li>
  </ul>
</nav>
<main>
  
    
    
        
    
    <section class="section-white li-columns">
        <div>
            <header class="pb0">
                <h1 id="title">Programming with Contractum</h1>
            </header>

            <p><a href="https://www.contractum.org"><strong>Contractum</strong></a> is a functional &amp; declarative
language for writing smart contracts which is a work-in-progress. The first
compiler version is planned for a release by the end of 2023; before that you
may use this section as a guideline and preview of how the development of RGB
smart contracts with contractum may look like in a future.</p>
<p>Contractum is a domain-specific language created with more general functional
language named <strong>ParselTongue</strong>. It uses
<a href="https://www.strict-types.org"><strong>Strict Types</strong></a> formalism for defining data
types and is compiled into RGB <em>schema</em>, <em>interfaces</em>, <em>interface
implementations</em>, <em>genesis</em>, <em>contract operations</em> and
<a href="https://www.aluvm.org"><strong>AluVM</strong></a> executable code. To learn more about RGB
schema, interfaces and other related concepts please refer to
<a href="/program/#components">RGB Components</a> section and <a href="https://www.rgbfaq.com">RGB FAQ</a>
website.</p>
<p>We will demonstrate how RGB with Contractum works in three main steps:</p>
<ul>
<li><a href="#basics" class="button button-secondary">Writing simple contract</a></li>
<li><a href="#fungibles" class="button button-secondary">Adding fungible state</a></li>
<li><a href="#interfaces" class="button button-secondary">Implementing interfaces</a></li>
</ul>

        </div>
    </section>
        
            
        
        
            
        
        <section class="section-green ">
            <div>
                <header  id="basics"  class="pb0">
                    <h2>Writing simple contract</h2>
                    <div class="highlight"></div>
                </header>

                <p>Let's do a contract which will work as a digital identity.</p>
<p>We have to start with definition of a data type representing the key. This is
not a part of the contract itself and may be imported into multiple contracts
from a <em>data type library</em>.</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#b48ead;">data </span><span style="color:#d08770;">PgpKey </span><span>:: curve </span><span style="color:#d08770;">U8</span><span>, key </span><span style="color:#d08770;">Bytes
</span></code></pre>
<p>As you might see, the code looks similar to Haskel. New data types are declared
with <code>data</code> keyword, and can be composed of named fields (being structs),
unnamed fields (tuples), operate as enums (in this case you should use
<code>|</code> instead of <code>,</code>), or unions, where each variant may in turn have an
associated structure or tuple. You may read more about constructing data types
in <a href="https://www.strict-types.org/">strict types</a> guidelines.</p>
<p>Now, having the data type we can start definition of our schema:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>schema </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>   </span><span style="color:#65737e;">-- This defines the atom of the contract state called `Identity`
</span><span>   </span><span style="color:#65737e;">-- which has data type `PgpKey`.
</span><span>   </span><span style="color:#65737e;">-- The `owned` keyword means that there is always a party
</span><span>   </span><span style="color:#65737e;">-- which owns the identity
</span><span>   owned </span><span style="color:#d08770;">Identity </span><span>:: </span><span style="color:#d08770;">PgpKey
</span><span>   </span><span style="color:#65737e;">-- an implicit part of the story is the fact that owned state
</span><span>   </span><span style="color:#65737e;">-- is always assigned to a single-use-seal definition, so the
</span><span>   </span><span style="color:#65737e;">-- proper way of writing the above statement will be
</span><span>   owned </span><span style="color:#d08770;">Identity </span><span>:: </span><span style="color:#d08770;">SingleUseSeal </span><span>-&gt; </span><span style="color:#d08770;">PgpKey
</span><span>   </span><span style="color:#65737e;">-- but we leave the part which repeats for each and every owned
</span><span>   </span><span style="color:#65737e;">-- state to reduce boilerplate of writing `SingleUseSeal -&gt;`
</span><span>   </span><span style="color:#65737e;">-- over and over again.
</span><span>
</span><span>   </span><span style="color:#65737e;">-- This says that to construct contract the user must provide
</span><span>   </span><span style="color:#65737e;">-- information about exactly one identity
</span><span>   </span><span style="color:#8fa1b3;">genesis </span><span style="color:#b48ead;">:: Identity
</span><span>
</span><span>   </span><span style="color:#65737e;">-- Now let&#39;s define what a owner of identity can do,
</span><span>   </span><span style="color:#65737e;">-- He can execute his rights by creating state transitions
</span><span>   </span><span style="color:#65737e;">-- (&quot;operation&quot; on the state) of predefined forms, like
</span><span>   op </span><span style="color:#d08770;">Revocation </span><span>:: old </span><span style="color:#d08770;">Identity </span><span>-&gt; new </span><span style="color:#d08770;">Identity
</span><span>   </span><span style="color:#65737e;">-- which does what it says: it revokes existing identity
</span><span>   </span><span style="color:#65737e;">-- and creates a new one.
</span></code></pre>
<p>As you may see, schema declares state which the contract operates, and
operations, which may update the state.</p>
<p>The state can be global and owned. The difference between these two forms of
state can be illustrated with following statements:</p>
<ul>
<li>
<p><strong>Global state</strong>: <em>nobody owns, everyone knows</em></p>
<p>Examples: asset name</p>
</li>
<li>
<p><strong>Owned state</strong>: <em>someone owns, nobody else knows</em></p>
<p>Examples: asset amounts, voting rights, NFT content</p>
</li>
</ul>
<p>In our example we do not define a global state yet.</p>
<p>There are also three types of operations:</p>
<ul>
<li><strong>Genesis</strong> - a unique operation which takes no input and sets up the contract;</li>
<li><strong>State transition</strong>, which changes some existing owned state ("inputs") and
may add up to the global state;</li>
<li><strong>State extensions</strong>, which may be seen as a "decentralized additional
geneses". State extensions do not have input state, but may produce new owned
state.</li>
</ul>
<p>The schema defines a rules of how the contract operates. Now let's put it into
a practice by creating a specific identity contract, and then doing a revocation:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>contract meSatoshiNakamoto implements </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>  </span><span style="color:#65737e;">-- this defines a genesis state and assigns it to a single-use-seal
</span><span>  assign orig </span><span style="color:#d08770;">Identity </span><span>:= 
</span><span>    (</span><span style="color:#d08770;">0xfac503c4641c3deda72a2d00bc9d6ff1094b15276c386efea403746a91436772</span><span>, </span><span style="color:#d08770;">1</span><span>)
</span><span>    -&gt; </span><span style="color:#d08770;">PgpKey</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0x028730eeeec41802621d177507b086f390ae600ba3ca5e428b13913af4c2cd25b3</span><span>)
</span><span>
</span><span>transition iLostMyKey executes </span><span style="color:#d08770;">Revocation
</span><span>  </span><span style="color:#65737e;">-- specifies the single-use-seal we close to match requirements
</span><span>  </span><span style="color:#65737e;">-- on the valid operation execution conditions
</span><span>  via meSatoshiNakamoto.orig
</span><span>  
</span><span>  </span><span style="color:#65737e;">-- here we use txid of the bitcoin transaction which will be
</span><span>  </span><span style="color:#65737e;">-- created to hold the commitment to this state transition,
</span><span>  </span><span style="color:#65737e;">-- called &quot;single-use-seal witness&quot;. Since we can not know the
</span><span>  </span><span style="color:#65737e;">-- txid upfront we use ~ to indicate the witness transaction id
</span><span>  assign upd </span><span style="color:#d08770;">Identity </span><span>:= (~, </span><span style="color:#d08770;">2</span><span>) 
</span><span>   -&gt; </span><span style="color:#d08770;">PgpKey</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0x0219db0a4e0eb8cb833608c08d76b9b279ec44a851ab82cc6fd68a9b32624bfa8b</span><span>)
</span><span>   </span><span style="color:#65737e;">-- the above defines new state and assigns it to a single-use-seal
</span></code></pre>

            </div>
        </section>
    
        
            
        
        
            
        
        <section class="section-red ">
            <div>
                <header  id="fungibles"  class="pb0">
                    <h2>Adding fungible state</h2>
                    <div class="highlight"></div>
                </header>

                <p>Now, let's add some tokens to the contract, in form of "I owe you" obligations
provided by the decentralized identity:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>schema </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>   owned </span><span style="color:#d08770;">Identity </span><span>:: </span><span style="color:#d08770;">PgpKey
</span><span>   owned </span><span style="color:#d08770;">IOYIssue </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>   </span><span style="color:#65737e;">-- `Zk64` means 64-bit unsigned integer hidden with zero-knowledge
</span><span>   owned </span><span style="color:#d08770;">IOYTokens </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>
</span><span>   global </span><span style="color:#d08770;">IOYTicker </span><span>:: </span><span style="color:#d08770;">String
</span><span>   global </span><span style="color:#d08770;">IOYName </span><span>:: </span><span style="color:#d08770;">String
</span><span>
</span><span>   </span><span style="color:#8fa1b3;">genesis </span><span style="color:#b48ead;">:: Identity</span><span>, </span><span style="color:#b48ead;">IOYTicker</span><span>, </span><span style="color:#b48ead;">IOYName
</span><span>
</span><span>   op </span><span style="color:#d08770;">Revocation </span><span>:: old </span><span style="color:#d08770;">Identity </span><span>-&gt; new </span><span style="color:#d08770;">Identity
</span><span>
</span><span>   op </span><span style="color:#d08770;">Promise </span><span>:: used </span><span style="color:#d08770;">IOYIssue </span><span>-&gt; given [</span><span style="color:#d08770;">IOYTokens</span><span>]?, remaining </span><span style="color:#d08770;">IOYIssue</span><span>?
</span><span>      assert used == sum given + (remaining ?? </span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>   op </span><span style="color:#d08770;">Transfer </span><span>:: spent {</span><span style="color:#d08770;">IOYTokens</span><span>} -&gt; received [</span><span style="color:#d08770;">IOYTokens</span><span>]
</span><span>      assert sum spent == sum received
</span></code></pre>
<p>Here we see multiple new things, let's try to explain them one by one.</p>
<p>First, it is the <code>global</code> keyword used to define asset ticker and name as two
strings.</p>
<p>We already covered <em>owned state</em> composed of the rights holder and state atoms;
but in some situations a contract needs a state which is "global" for the
contract and is not "owned" by anyone (i.e. not assigned to a UTXO
single-use-seal). The name of the asset (and ticker) is that sort of
information: in the examples above it does not "belong" to a contract party but
instead is a "property" of the contract itself. Another example could be the
name of the identity holder which can't be changed and thus can't be assigned to
a UTXO single-use-seal. Such state is defined with the <code>global</code> keyword.</p>
<p>It is important to note, that while the global state is not "directly owned" by
any party, it still may be updated through state transitions -- but only if
schema enables that explicitly. In such cases the use of the global state (as
compared to the owned state) is reasonable only when the user may opt-out from
future state updates (i.e. do not define a new single-use-seals) but still needs
to keep the state. The asset name is again such an example, since even if the
asset can be renamed, future renames after certain renaming may be prohibited
(i.e. no new owned state can be created), but the asset name should stay.
<code>global</code> allows exactly that.</p>
<p>Second, the use of braces, brackets and question mark around and next to the
state name. Both braces and brackets mean that the operation works not with a
single <em>state atom</em>, but instead an array (brackets) or set (braces) of <em>state
atoms</em>. Set differs from an array in the fact that all elements of the set must
be unique, while in array they may repeat. Coming back to our operations, asset
transfer may spend a number of assets from different owners, but all of them
must be unique (to prevent double-spend), i.e. form a set. However, when
defining a receivers, multiple <em>state atoms</em> may be equal (i.e. you can send
10 tokens to the same UTXO <code>N</code> times, such that the receiver will get <code>10*N</code>
tokens in total, but through different "inputs", which may increase privacy).</p>
<p>Question mark is used to inform that the <em>state</em> may be absent, i.e. in case of
array or set it can be empty - or in case of a single item, it is optional.</p>
<p>At the very beginning we had mentioned so-called <em>state extensions</em>. State
extension can be created by anybody without doing an on-chain commitment (i.e.
without closing any single-use-seals). In this it is similar to <em>genesis</em>.
However, the state created by the extension is not "final" (compare to a
non-mined transaction in the bitcoin mempool) until it gets included into a
valid state transition (like transaction gets mined by being included into
bitcoin valid block).</p>
<p>Probably the simplest way to understand state extensions is by example. Let's
assume we'd like to do an asset which can be issued by anybody in the world
through burning equivalent amount of bitcoins. Such operation can't be a state
transition, since we do not have a predefined set of single-use-seals to define
a "rights of issue" for an open and unknown set of participants. We can't also
do "multiple geneses", since each genesis will define a new RGB contract and
the assets under different RGB contracts are not fungible. State extensions
were created exactly to address this issue. A contract using them may look in
the following way:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#65737e;">-- We need some basic bitcoin-related types
</span><span style="color:#65737e;">-- We can do `import BP.{Utxo, RedeemScript, ...}`, but here we&#39;d like to use
</span><span style="color:#65737e;">-- this opportunity to showcase how type definitions work
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Utxo </span><span>:: </span><span style="color:#d08770;">Txid</span><span>, vout </span><span style="color:#d08770;">U16
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Txid </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">32</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">RedeemScript </span><span>:: </span><span style="color:#d08770;">Bytes
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">CompressedPk </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">33</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">XonlyPk </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">32</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">OutputDescriptor </span><span>:: </span><span style="color:#d08770;">Wpkh </span><span>| </span><span style="color:#d08770;">Tr
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Wpkh </span><span>:: </span><span style="color:#d08770;">CompressedPk
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Tr </span><span>:: </span><span style="color:#d08770;">XOnlyPk
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">ProofOfBurn </span><span>::
</span><span>  burned </span><span style="color:#d08770;">Utxo</span><span>,
</span><span>  descriptor </span><span style="color:#d08770;">OutputDescriptor
</span><span>  </span><span style="color:#65737e;">-- output descriptor is used to prove that the bitcoins can&#39;t be spent.
</span><span>  </span><span style="color:#65737e;">-- in the validation logic below we define that PoB output must be either
</span><span>  </span><span style="color:#65737e;">-- SegWit v0 WPKH or taproot output with a keypath-spending; in both cases
</span><span>  </span><span style="color:#65737e;">-- the key given as a prove must be tweaked with its own hash, which will
</span><span>  </span><span style="color:#65737e;">-- construct provably-unspendable key
</span><span>
</span><span>schema </span><span style="color:#d08770;">RgbWrapBtc
</span><span>  global </span><span style="color:#d08770;">Ticker </span><span>:: </span><span style="color:#d08770;">String
</span><span>  global </span><span style="color:#d08770;">Name </span><span>:: </span><span style="color:#d08770;">String
</span><span>
</span><span>  owned </span><span style="color:#d08770;">Value </span><span>:: </span><span style="color:#d08770;">Zk64 </span><span style="color:#65737e;">-- the assets will be ownable and transferrable as any
</span><span>                      </span><span style="color:#65737e;">-- other fungible asset
</span><span>
</span><span>  valency </span><span style="color:#d08770;">Burn </span><span style="color:#65737e;">-- the valency declares a possibility of the public 
</span><span>               </span><span style="color:#65737e;">-- participation in the contract logic.
</span><span>               </span><span style="color:#65737e;">-- If the contract may have different forms of public 
</span><span>               </span><span style="color:#65737e;">-- participation, each of them must be declared first.
</span><span>
</span><span>  </span><span style="color:#8fa1b3;">genesis </span><span style="color:#b48ead;">:: Ticker</span><span>, </span><span style="color:#b48ead;">Name</span><span>, </span><span style="color:#65737e;">-- in genesis we can&#39;t issue anything, we just
</span><span>                           </span><span style="color:#65737e;">-- declare specific name and ticker for our wrapped
</span><span>                           </span><span style="color:#65737e;">-- bitcoin
</span><span>             </span><span style="color:#b48ead;">Burn </span><span style="color:#65737e;">-- we also say that the genesis allows state extensions to
</span><span>                  </span><span style="color:#65737e;">-- be directly linked to the contract
</span><span>
</span><span>  </span><span style="color:#65737e;">-- this is the state extension procedure: a &quot;public&quot; method of the contract
</span><span>  </span><span style="color:#65737e;">-- which takes information about the proof of burn and allows to issue the
</span><span>  </span><span style="color:#65737e;">-- wrapped bitcoins assigned to a single-use-seal(s), which are lately can
</span><span>  </span><span style="color:#65737e;">-- be transferred with a usual state transition.
</span><span>  public </span><span style="color:#d08770;">Issue </span><span>:: </span><span style="color:#d08770;">Burn</span><span>, proof </span><span style="color:#d08770;">ProofOfBurn </span><span>-&gt; issued [</span><span style="color:#d08770;">Value</span><span>]
</span><span>    </span><span style="color:#65737e;">-- here we verify that the UTXO input constructed with the key given in
</span><span>    </span><span style="color:#65737e;">-- the proof according to the provably-unspent procedure exactly matches
</span><span>    </span><span style="color:#65737e;">-- output existing on-chain
</span><span>    </span><span style="color:#b48ead;">let</span><span> spk&#39; = match proof.descriptor
</span><span>      </span><span style="color:#d08770;">Wpkh</span><span>(pk) =&gt;
</span><span>        pk |&gt;
</span><span>        </span><span style="color:#d08770;">Hash</span><span>.sha256 |&gt;              </span><span style="color:#65737e;">-- h = Hash.sha256 pk
</span><span>        </span><span style="color:#d08770;">SECP</span><span>.gen |&gt;                 </span><span style="color:#65737e;">-- tweak = SECP.gen h
</span><span>        </span><span style="color:#d08770;">SECP</span><span>.add pk |&gt;              </span><span style="color:#65737e;">-- pk&#39; = SECP.add pk, tweak
</span><span>        </span><span style="color:#d08770;">Hash</span><span>.hash160 |&gt;             </span><span style="color:#65737e;">-- h&#39; = Hash.hash160 pk&#39;&#39;
</span><span>        </span><span style="color:#d08770;">BP</span><span>.wpkhScriptPubkey         </span><span style="color:#65737e;">-- BP.wpkhScriptPubkey h&#39;
</span><span>      </span><span style="color:#d08770;">Tr</span><span>(xpk) =&gt;
</span><span>        xpk |&gt;
</span><span>        </span><span style="color:#d08770;">BIP340</span><span>.selfTweak |&gt;         </span><span style="color:#65737e;">-- xpk&#39; = BIP340.selfTweak xpk
</span><span>        </span><span style="color:#d08770;">BP</span><span>.trScriptPubkey           </span><span style="color:#65737e;">-- BP.trScriptPubkey xpk&#39;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> spk = assert </span><span style="color:#d08770;">BP</span><span>.readScriptPubkey proof.burned
</span><span>    assert spk == spk&#39;
</span><span>    assert </span><span style="color:#d08770;">BP</span><span>.notSpent proof.burned
</span><span>    assert </span><span style="color:#d08770;">BP</span><span>.value proof.burned == sum issued
</span><span>
</span><span>  op </span><span style="color:#d08770;">Transfer </span><span>:: spent {</span><span style="color:#d08770;">Value</span><span>} -&gt; received [</span><span style="color:#d08770;">Value</span><span>]
</span><span>    assert sum spent == sum received
</span></code></pre>

            </div>
        </section>
    
        
            
        
        
            
        
        <section class="section-purple ">
            <div>
                <header  id="interfaces"  class="pb0">
                    <h2>Contract interfaces</h2>
                    <div class="highlight"></div>
                </header>

                <p>But how the wallet makes the sense of the contract? RGB contract can do a lot of things, and if schema developers would need to do a separate wallet for each schema the entrance threshold would be too high. To avoid such situation a concept of <em>contract interface</em> was created. A <em>contract interface</em> is a standard way communicating with RGB Node asking it for a semantically-meaningful state and creating operations. Such concept of interface is similar to the concept of ERC standards and ABI files in Ethereum world; the most common interfaces are called "RGBxx" and are defined as a separate LNP/BP standards.</p>
<p>Here, instead of using existing interface standards we will create an interface for a generic fungible token from scratch to explain the way they work:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>interface </span><span style="color:#d08770;">FungibleToken</span><span>:
</span><span>   global </span><span style="color:#d08770;">Ticker </span><span>-&gt; </span><span style="color:#d08770;">String </span><span style="color:#65737e;">-- this is similar to schema definition; in fact
</span><span>                           </span><span style="color:#65737e;">-- it is a requirement that the schema must provide
</span><span>                           </span><span style="color:#65737e;">-- a global state of the String type and link it to
</span><span>                           </span><span style="color:#65737e;">-- the &quot;Ticker&quot; name
</span><span>   global </span><span style="color:#d08770;">Name </span><span>-&gt; </span><span style="color:#d08770;">String
</span><span>
</span><span>   </span><span style="color:#65737e;">-- amount of the issued asset must be a owned state which should be
</span><span>   </span><span style="color:#65737e;">-- accessible to all contract participants, hence it is `public`
</span><span>   owned public </span><span style="color:#d08770;">Inflation </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>   owned </span><span style="color:#d08770;">Asset </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>
</span><span>   op </span><span style="color:#d08770;">Issue </span><span>:: </span><span style="color:#d08770;">Inflation </span><span>-&gt; [</span><span style="color:#d08770;">Asset</span><span>]?, </span><span style="color:#d08770;">Inflation</span><span>? </span><span style="color:#65737e;">-- and operations
</span><span>   op </span><span style="color:#d08770;">Transfer </span><span>:: {</span><span style="color:#d08770;">Asset</span><span>} -&gt; [</span><span style="color:#d08770;">Asset</span><span>]
</span><span>
</span><span style="color:#65737e;">-- Specific schema state may use different naming, for instance because a
</span><span style="color:#65737e;">-- schema can define multiple assets with different names; in that case we
</span><span style="color:#65737e;">-- will have multiple interface implementations referencing different state.
</span><span>implement </span><span style="color:#d08770;">FungibleToken</span><span> for </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>   global </span><span style="color:#d08770;">Ticker </span><span>:= </span><span style="color:#d08770;">IOYTicker </span><span style="color:#65737e;">-- this creates a _binding_ of the state defined
</span><span>                              </span><span style="color:#65737e;">-- in the schema (*IOYTicker* in this case) to
</span><span>                              </span><span style="color:#65737e;">-- the interface
</span><span>   global </span><span style="color:#d08770;">Name </span><span>:= </span><span style="color:#d08770;">IOYName
</span><span>   owned </span><span style="color:#d08770;">Inflation </span><span>:= </span><span style="color:#d08770;">IOYIssue
</span><span>   owned </span><span style="color:#d08770;">Asset </span><span>:= </span><span style="color:#d08770;">IOYTokens
</span><span>   op </span><span style="color:#d08770;">Issue </span><span>:= </span><span style="color:#d08770;">Promise
</span><span>   op </span><span style="color:#d08770;">Transfer </span><span style="color:#65737e;">-- here we skip `:=` part since the interface operation name
</span><span>               </span><span style="color:#65737e;">-- matches the name used in the schema. In such cases we can
</span><span>               </span><span style="color:#65737e;">-- also skip the declaration at whole
</span></code></pre>
<p>RGB smart contract can implement multiple interfaces. In our case it would be
desirable to expose the identity information as well:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>interface </span><span style="color:#d08770;">PgpIdentity
</span><span>  owned </span><span style="color:#d08770;">Identity </span><span>:: </span><span style="color:#d08770;">PgpKey
</span><span>  exec </span><span style="color:#d08770;">Revocation </span><span>:: old </span><span style="color:#d08770;">Identity </span><span>-&gt; new </span><span style="color:#d08770;">Identity
</span><span>
</span><span>implement </span><span style="color:#d08770;">PgpIdentity</span><span> for </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>  </span><span style="color:#65737e;">-- we do not need to put anything here since schema state and operation
</span><span>  </span><span style="color:#65737e;">-- names matches interface requirements and the compiler is able to guess
</span><span>  </span><span style="color:#65737e;">-- the bindings
</span></code></pre>

            </div>
        </section>
    
</main>

<footer><div class="w-100 mw-none ph3 mw8-m mw9-l center f3">
  <div class="flex flex-column flex-row-ns pv0-l">
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Get help!</h4>
      <ul>
        <li><a href="http://rgbfaq.com">RGB FAQ</a></li>
        <li><a href="https://blackpaper.rgb.tech">White paper</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="https://standards.lnp-bp.org">Standards</a></li>
      </ul>
    </div>
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Terms and policies</h4>
      <ul>
        <li><a href="/policies/licenses">Licenses</a></li>
        <li><a href="/policies/logo-policy-and-media-guide/">Logo Policy and Media Guide</a></li>
        <li><a href="/policies/security">Security Disclosures</a></li>
        <li><a href="/policies/privacy-policy/">Privacy Notice</a></li>
      </ul>
    </div>
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Social</h4>
      <div class="flex flex-row flex-wrap">
        <a href="https://twitter.com/lnp_bp"><img src="/social/twitter.svg" alt="twitter logo" title="Twitter"></a>
        <a href="https://www.youtube.com/LNP-BP"><img class="pv2" src="/social/youtube.svg" alt="youtube logo" title="YouTube"></a>
        <a href="https://reddit.com/r/RGB_protocol"><img src="/social/reddit.svg" alt="discord logo" title="Discord"></a>
        <a href="https://github.com/RGB-WG"><img src="/social/github.svg" alt="github logo" title="GitHub"></a>
      </div>
    </div>

  </div>
  <div class="attribution">
    <p>
      Maintained by the <a href="https://www.lnp-bp.org">LNP/BP Standards Association</a>. See a bug?
      <a href="https://github.com/RGB-WG/rgb.tech/issues/new">File an issue!</a>
    </p>
    <p>Uses layout &amp; styles from <a href="https://github.com/rust-lang/www.rust-lang.org" target="_blank">Rust Language website</a></p>
  </div>
</div>

</footer>
</body>

</html>
