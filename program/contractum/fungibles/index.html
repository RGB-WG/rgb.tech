<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>RGB smart contracts</title>
  <link rel="stylesheet" href="/tachyons-ext.css">
  <link rel="stylesheet" href="/fonts.css">
  <link rel="stylesheet" href="/front.css">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  <meta http-equiv="pragma" content="no-cache">
  
    <meta name="description" content="">

    <meta property="og:title" content="Adding fungible state" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://rgb.tech/rgb-banner.png" />
    <meta name="twitter:card" content="summary_large_image">

    <meta property="og:description" content="">
    <meta property="og:site_name" content="RGB protocol">

    <meta name="twitter:site" content="@lnp_bp">

</head>

<body>
<nav class="flex flex-row justify-center justify-end-l items-center flex-wrap ph2 pl3-ns pr3-ns pb3">
  <div id="logo" class="flex-auto w-100 w-auto-l self-start self-center tc tl-l">
    <a href="/">
      <img alt="RGB Logo" src="/logo/rgb-symbol-color.svg">
    </a>
  </div>
  <ul class="nav list w-100 w-auto-l flex flex-none flex-row flex-wrap justify-center justify-end-l items-center pv2 ph0 ph4-ns">
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/install">Install</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/learn">Learn</a></li>
    <!-- li class="tc pv2 ph2 ph4-ns flex-20-s">Tools</li -->
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/governance">Governance</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="https://t.me/rgbtelegram">Community</a></li>
    <li class="tc pv2 ph2 ph4-ns flex-20-s"><a href="/blog">Blog</a></li>
  </ul>
</nav>
<main>
  
<section class="section-white">
    <div>
        <header class="pb0">
            <h1>Adding fungible state</h1>
            <div class="highlight"></div>
        </header>

        <p>Now, let's add some tokens to the contract, in form of "I owe you" obligations
provided by the decentralized identity:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span>schema </span><span style="color:#d08770;">DecentralizedIdentity
</span><span>   owned </span><span style="color:#d08770;">Identity </span><span>:: </span><span style="color:#d08770;">PgpKey
</span><span>   owned </span><span style="color:#d08770;">IOYIssue </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>   </span><span style="color:#65737e;">-- `Zk64` means 64-bit unsigned integer hidden with zero-knowledge
</span><span>   owned </span><span style="color:#d08770;">IOYTokens </span><span>:: </span><span style="color:#d08770;">Zk64
</span><span>
</span><span>   global </span><span style="color:#d08770;">IOYTicker </span><span>:: </span><span style="color:#d08770;">String
</span><span>   global </span><span style="color:#d08770;">IOYName </span><span>:: </span><span style="color:#d08770;">String
</span><span>
</span><span>   </span><span style="color:#8fa1b3;">genesis </span><span style="color:#b48ead;">:: Identity</span><span>, </span><span style="color:#b48ead;">IOYTicker</span><span>, </span><span style="color:#b48ead;">IOYName
</span><span>
</span><span>   op </span><span style="color:#d08770;">Revocation </span><span>:: old </span><span style="color:#d08770;">Identity </span><span>-&gt; new </span><span style="color:#d08770;">Identity
</span><span>
</span><span>   op </span><span style="color:#d08770;">Promise </span><span>:: used </span><span style="color:#d08770;">IOYIssue </span><span>-&gt; given [</span><span style="color:#d08770;">IOYTokens</span><span>]?, remaining </span><span style="color:#d08770;">IOYIssue</span><span>?
</span><span>      assert used == sum given + (remaining ?? </span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>   op </span><span style="color:#d08770;">Transfer </span><span>:: spent {</span><span style="color:#d08770;">IOYTokens</span><span>} -&gt; received [</span><span style="color:#d08770;">IOYTokens</span><span>]
</span><span>      assert sum spent == sum received
</span></code></pre>
<p>Here we see multiple new things, let's try to explain them one by one.</p>
<p>First, it is the <code>global</code> keyword used to define asset ticker and name as two
strings.</p>
<p>We already covered <em>owned state</em> composed of the rights holder and state atoms;
but in some situations a contract needs a state which is "global" for the
contract and is not "owned" by anyone (i.e. not assigned to a UTXO
single-use-seal). The name of the asset (and ticker) is that sort of
information: in the examples above it does not "belong" to a contract party but
instead is a "property" of the contract itself. Another example could be the
name of the identity holder which can't be changed and thus can't be assigned to
a UTXO single-use-seal. Such state is defined with the <code>global</code> keyword.</p>
<p>It is important to note, that while the global state is not "directly owned" by
any party, it still may be updated through state transitions -- but only if
schema enables that explicitly. In such cases the use of the global state (as
compared to the owned state) is reasonable only when the user may opt-out from
future state updates (i.e. do not define a new single-use-seals) but still needs
to keep the state. The asset name is again such an example, since even if the
asset can be renamed, future renames after certain renaming may be prohibited
(i.e. no new owned state can be created), but the asset name should stay.
<code>global</code> allows exactly that.</p>
<p>Second, the use of braces, brackets and question mark around and next to the
state name. Both braces and brackets mean that the operation works not with a
single <em>state atom</em>, but instead an array (brackets) or set (braces) of <em>state
atoms</em>. Set differs from an array in the fact that all elements of the set must
be unique, while in array they may repeat. Coming back to our operations, asset
transfer may spend a number of assets from different owners, but all of them
must be unique (to prevent double-spend), i.e. form a set. However, when
defining a receivers, multiple <em>state atoms</em> may be equal (i.e. you can send
10 tokens to the same UTXO <code>N</code> times, such that the receiver will get <code>10*N</code>
tokens in total, but through different "inputs", which may increase privacy).</p>
<p>Question mark is used to inform that the <em>state</em> may be absent, i.e. in case of
array or set it can be empty - or in case of a single item, it is optional.</p>
<p>At the very beginning we had mentioned so-called <em>state extensions</em>. State
extension can be created by anybody without doing an on-chain commitment (i.e.
without closing any single-use-seals). In this it is similar to <em>genesis</em>.
However, the state created by the extension is not "final" (compare to a
non-mined transaction in the bitcoin mempool) until it gets included into a
valid state transition (like transaction gets mined by being included into
bitcoin valid block).</p>
<p>Probably the simplest way to understand state extensions is by example. Let's
assume we'd like to do an asset which can be issued by anybody in the world
through burning equivalent amount of bitcoins. Such operation can't be a state
transition, since we do not have a predefined set of single-use-seals to define
a "rights of issue" for an open and unknown set of participants. We can't also
do "multiple geneses", since each genesis will define a new RGB contract and
the assets under different RGB contracts are not fungible. State extensions
were created exactly to address this issue. A contract using them may look in
the following way:</p>
<pre data-lang="haskell" style="background-color:#2b303b;color:#c0c5ce;" class="language-haskell "><code class="language-haskell" data-lang="haskell"><span style="color:#65737e;">-- We need some basic bitcoin-related types
</span><span style="color:#65737e;">-- We can do `import BP.{Utxo, RedeemScript, ...}`, but here we&#39;d like to use
</span><span style="color:#65737e;">-- this opportunity to showcase how type definitions work
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Utxo </span><span>:: </span><span style="color:#d08770;">Txid</span><span>, vout </span><span style="color:#d08770;">U16
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Txid </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">32</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">RedeemScript </span><span>:: </span><span style="color:#d08770;">Bytes
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">CompressedPk </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">33</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">XonlyPk </span><span>:: [</span><span style="color:#d08770;">Byte</span><span>^</span><span style="color:#d08770;">32</span><span>]
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">OutputDescriptor </span><span>:: </span><span style="color:#d08770;">Wpkh </span><span>| </span><span style="color:#d08770;">Tr
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Wpkh </span><span>:: </span><span style="color:#d08770;">CompressedPk
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">Tr </span><span>:: </span><span style="color:#d08770;">XOnlyPk
</span><span>
</span><span style="color:#b48ead;">data </span><span style="color:#d08770;">ProofOfBurn </span><span>::
</span><span>  burned </span><span style="color:#d08770;">Utxo</span><span>,
</span><span>  descriptor </span><span style="color:#d08770;">OutputDescriptor
</span><span>  </span><span style="color:#65737e;">-- output descriptor is used to prove that the bitcoins can&#39;t be spent.
</span><span>  </span><span style="color:#65737e;">-- in the validation logic below we define that PoB output must be either
</span><span>  </span><span style="color:#65737e;">-- SegWit v0 WPKH or taproot output with a keypath-spending; in both cases
</span><span>  </span><span style="color:#65737e;">-- the key given as a prove must be tweaked with its own hash, which will
</span><span>  </span><span style="color:#65737e;">-- construct provably-unspendable key
</span><span>
</span><span>schema </span><span style="color:#d08770;">RgbWrapBtc
</span><span>  global </span><span style="color:#d08770;">Ticker </span><span>:: </span><span style="color:#d08770;">String
</span><span>  global </span><span style="color:#d08770;">Name </span><span>:: </span><span style="color:#d08770;">String
</span><span>
</span><span>  owned </span><span style="color:#d08770;">Value </span><span>:: </span><span style="color:#d08770;">Zk64 </span><span style="color:#65737e;">-- the assets will be ownable and transferrable as any
</span><span>                      </span><span style="color:#65737e;">-- other fungible asset
</span><span>
</span><span>  valency </span><span style="color:#d08770;">Burn </span><span style="color:#65737e;">-- the valency declares a possibility of the public 
</span><span>               </span><span style="color:#65737e;">-- participation in the contract logic.
</span><span>               </span><span style="color:#65737e;">-- If the contract may have different forms of public 
</span><span>               </span><span style="color:#65737e;">-- participation, each of them must be declared first.
</span><span>
</span><span>  </span><span style="color:#8fa1b3;">genesis </span><span style="color:#b48ead;">:: Ticker</span><span>, </span><span style="color:#b48ead;">Name</span><span>, </span><span style="color:#65737e;">-- in genesis we can&#39;t issue anything, we just
</span><span>                           </span><span style="color:#65737e;">-- declare specific name and ticker for our wrapped
</span><span>                           </span><span style="color:#65737e;">-- bitcoin
</span><span>             </span><span style="color:#b48ead;">Burn </span><span style="color:#65737e;">-- we also say that the genesis allows state extensions to
</span><span>                  </span><span style="color:#65737e;">-- be directly linked to the contract
</span><span>
</span><span>  </span><span style="color:#65737e;">-- this is the state extension procedure: a &quot;public&quot; method of the contract
</span><span>  </span><span style="color:#65737e;">-- which takes information about the proof of burn and allows to issue the
</span><span>  </span><span style="color:#65737e;">-- wrapped bitcoins assigned to a single-use-seal(s), which are lately can
</span><span>  </span><span style="color:#65737e;">-- be transferred with a usual state transition.
</span><span>  public </span><span style="color:#d08770;">Issue </span><span>:: </span><span style="color:#d08770;">Burn</span><span>, proof </span><span style="color:#d08770;">ProofOfBurn </span><span>-&gt; issued [</span><span style="color:#d08770;">Value</span><span>]
</span><span>    </span><span style="color:#65737e;">-- here we verify that the UTXO input constructed with the key given in
</span><span>    </span><span style="color:#65737e;">-- the proof according to the provably-unspent procedure exactly matches
</span><span>    </span><span style="color:#65737e;">-- output existing on-chain
</span><span>    </span><span style="color:#b48ead;">let</span><span> spk&#39; = match proof.descriptor
</span><span>      </span><span style="color:#d08770;">Wpkh</span><span>(pk) =&gt;
</span><span>        pk |&gt;
</span><span>        </span><span style="color:#d08770;">Hash</span><span>.sha256 |&gt;              </span><span style="color:#65737e;">-- h = Hash.sha256 pk
</span><span>        </span><span style="color:#d08770;">SECP</span><span>.gen |&gt;                 </span><span style="color:#65737e;">-- tweak = SECP.gen h
</span><span>        </span><span style="color:#d08770;">SECP</span><span>.add pk |&gt;              </span><span style="color:#65737e;">-- pk&#39; = SECP.add pk, tweak
</span><span>        </span><span style="color:#d08770;">Hash</span><span>.hash160 |&gt;             </span><span style="color:#65737e;">-- h&#39; = Hash.hash160 pk&#39;&#39;
</span><span>        </span><span style="color:#d08770;">BP</span><span>.wpkhScriptPubkey         </span><span style="color:#65737e;">-- BP.wpkhScriptPubkey h&#39;
</span><span>      </span><span style="color:#d08770;">Tr</span><span>(xpk) =&gt;
</span><span>        xpk |&gt;
</span><span>        </span><span style="color:#d08770;">BIP340</span><span>.selfTweak |&gt;         </span><span style="color:#65737e;">-- xpk&#39; = BIP340.selfTweak xpk
</span><span>        </span><span style="color:#d08770;">BP</span><span>.trScriptPubkey           </span><span style="color:#65737e;">-- BP.trScriptPubkey xpk&#39;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> spk = assert </span><span style="color:#d08770;">BP</span><span>.readScriptPubkey proof.burned
</span><span>    assert spk == spk&#39;
</span><span>    assert </span><span style="color:#d08770;">BP</span><span>.notSpent proof.burned
</span><span>    assert </span><span style="color:#d08770;">BP</span><span>.value proof.burned == sum issued
</span><span>
</span><span>  op </span><span style="color:#d08770;">Transfer </span><span>:: spent {</span><span style="color:#d08770;">Value</span><span>} -&gt; received [</span><span style="color:#d08770;">Value</span><span>]
</span><span>    assert sum spent == sum received
</span></code></pre>

    </div>
</section>

</main>

<footer><div class="w-100 mw-none ph3 mw8-m mw9-l center f3">
  <div class="flex flex-column flex-row-ns pv0-l">
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Get help!</h4>
      <ul>
        <li><a href="http://rgbfaq.com">RGB FAQ</a></li>
        <li><a href="https://blackpaper.rgb.tech">White paper</a></li>
        <li><a href="/docs">Documentation</a></li>
        <li><a href="https://standards.lnp-bp.org">Standards</a></li>
      </ul>
    </div>
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Terms and policies</h4>
      <ul>
        <li><a href="/policies/licenses">Licenses</a></li>
        <li><a href="/policies/logo-policy-and-media-guide/">Logo Policy and Media Guide</a></li>
        <li><a href="/policies/security">Security Disclosures</a></li>
        <li><a href="/policies/privacy-policy/">Privacy Notice</a></li>
      </ul>
    </div>
    <div class="flex flex-column mw8 w-100 measure-wide-l pv2 pv5-m pv2-ns ph4-m ph4-l">
      <h4>Social</h4>
      <div class="flex flex-row flex-wrap">
        <a href="https://twitter.com/lnp_bp"><img src="/social/twitter.svg" alt="twitter logo" title="Twitter"></a>
        <a href="https://www.youtube.com/LNP-BP"><img class="pv2" src="/social/youtube.svg" alt="youtube logo" title="YouTube"></a>
        <a href="https://reddit.com/r/RGB_protocol"><img src="/social/reddit.svg" alt="discord logo" title="Discord"></a>
        <a href="https://github.com/RGB-WG"><img src="/social/github.svg" alt="github logo" title="GitHub"></a>
      </div>
    </div>

  </div>
  <div class="attribution">
    <p>
      Maintained by the <a href="https://www.lnp-bp.org">LNP/BP Standards Association</a>. See a bug?
      <a href="https://github.com/RGB-WG/rgb.tech/issues/new">File an issue!</a>
    </p>
    <p>Uses layout &amp; styles from <a href="https://github.com/rust-lang/www.rust-lang.org" target="_blank">Rust Language website</a></p>
  </div>
</div>

</footer>
</body>

</html>
